{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Kuziv/Desktop/Desktop%20Folders/Client%20Projects/MVp/mvp-web-agency/node_modules/msgpackr/unpack.js"],"sourcesContent":["var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tif (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every(item => ['string', 'number', 'boolean', 'bigint'].includes(typeof item))) {\n\t\treturn property.flat().toString();\n\t}\n\tthrow new Error(`Invalid property type for record: ${typeof property}`);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString) // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = data => {\n\tlet headLength = (data.byteLength % 8) || 8\n\tlet head = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0])\n\tfor (let i = 1; i < headLength; i++) {\n\t\thead <<= BigInt(8)\n\t\thead += BigInt(data[i])\n\t}\n\tif (data.byteLength !== headLength) {\n\t\tlet view = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\t\tlet decode = (start, end) => {\n\t\t\tlet length = end - start\n\t\t\tif (length <= 40) {\n\t\t\t\tlet out = view.getBigUint64(start)\n\t\t\t\tfor (let i = start + 8; i < end; i += 8) {\n\t\t\t\t\tout <<= BigInt(64n)\n\t\t\t\t\tout |= view.getBigUint64(i)\n\t\t\t\t}\n\t\t\t\treturn out\n\t\t\t}\n\t\t\t// if (length === 8) return view.getBigUint64(start)\n\t\t\tlet middle = start + (length >> 4 << 3)\n\t\t\tlet left = decode(start, middle)\n\t\t\tlet right = decode(middle, end)\n\t\t\treturn (left << BigInt((end - middle) * 8)) | right\n\t\t}\n\t\thead = (head << BigInt((view.byteLength - headLength) * 8)) | decode(headLength, view.byteLength)\n\t}\n\treturn head\n}\n\nlet errors = {\n\tError, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError: typeof AggregateError === 'function' ? AggregateError : null,\n}\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\tif (!errors[data[0]]) {\n\t\tlet error = Error(data[1], { cause: data[2] })\n\t\terror.name = data[0]\n\t\treturn error\n\t}\n\treturn errors[data[0]](data[1], { cause: data[2] })\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle any other types that can cycle and make the code more robust if there are other extensions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse if (token >= 0x80 && token < 0x90 || token == 0xde || token == 0xdf)\n\t\ttarget = new Map()\n\telse if ((token >= 0xc7 && token <= 0xc9 || token >= 0xd4 && token <= 0xd8) && src[position + 1] === 0x73)\n\t\ttarget = new Set()\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (!refEntry.used) {\n\t\t// no cycle, can just use the returned read object\n\t\treturn refEntry.target = targetProperties // replace the placeholder with the real one\n\t} else {\n\t\t// there is a cycle, so we have to assign properties to original target\n\t\tObject.assign(target, targetProperties)\n\t}\n\n\t// copy over map/set entries if we're able to\n\tif (target instanceof Map)\n\t\tfor (let [k, v] of targetProperties.entries()) target.set(k, v)\n\tif (target instanceof Set)\n\t\tfor (let i of Array.from(targetProperties)) target.add(i)\n\treturn target\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\t// we always have to slice to get a new ArrayBuffer that is aligned\n\tlet buffer = Uint8Array.prototype.slice.call(data, 1).buffer\n\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) return buffer\n\t\tif (typeCode === 17) return new DataView(buffer)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\treturn new glbl[typedArrayName](buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n}\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1208, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Kuziv/Desktop/Desktop%20Folders/Client%20Projects/MVp/mvp-web-agency/node_modules/msgpackr/pack.js"],"sourcesContent":["import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, target.byteLength - position)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < 0x8000000000000000 && value >= -0x8000000000000000) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < 0x10000000000000000 && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.largeBigIntToString) {\n\t\t\t\t\t\treturn pack(value.toString());\n\t\t\t\t\t} else if (this.useBigIntExtension || this.moreTypes) {\n\t\t\t\t\t\tlet empty = value < 0 ? BigInt(-1) : BigInt(0)\n\n\t\t\t\t\t\tlet array\n\t\t\t\t\t\tif (value >> BigInt(0x10000) === empty) {\n\t\t\t\t\t\t\tlet mask = BigInt(0x10000000000000000) - BigInt(1) // literal would overflow\n\t\t\t\t\t\t\tlet chunks = []\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tchunks.push(value & mask)\n\t\t\t\t\t\t\t\tif ((value >> BigInt(63)) === empty) break\n\t\t\t\t\t\t\t\tvalue >>= BigInt(64)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tarray = new Uint8Array(new BigUint64Array(chunks).buffer)\n\t\t\t\t\t\t\tarray.reverse()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet invert = value < 0\n\t\t\t\t\t\t\tlet string = (invert ? ~value : value).toString(16)\n\t\t\t\t\t\t\tif (string.length % 2) {\n\t\t\t\t\t\t\t\tstring = '0' + string\n\t\t\t\t\t\t\t} else if (parseInt(string.charAt(0), 16) >= 8) {\n\t\t\t\t\t\t\t\tstring = '00' + string\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (hasNodeBuffer) {\n\t\t\t\t\t\t\t\tarray = Buffer.from(string, 'hex')\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tarray = new Uint8Array(string.length / 2)\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\t\t\t\t\tarray[i] = parseInt(string.slice(i * 2, i * 2 + 2), 16)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (invert) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) array[i] = ~array[i]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (array.length + position > safeEnd)\n\t\t\t\t\t\t\tmakeRoom(array.length + position)\n\t\t\t\t\t\tposition = writeExtensionData(array, target, position, 0x42)\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +\n\t\t\t\t\t\t\t' largeBigIntToString to convert to string')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys;\n\t\t\tif (this.skipValues) {\n\t\t\t\tkeys = [];\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n\t\t\t\t\t\t!this.skipValues.includes(object[key]))\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys = Object.keys(object)\n\t\t\t}\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0xffff) {\n\t\t\t\tthrow new Error('Object is too large to serialize with fast 16-bit map size,' +\n\t\t\t\t' use the \"variableMapSize\" option to serialize this object');\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// create reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength))\n\t\ttargetView = target.dataView;\n\t\tposition = 0\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, DataView, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x11, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray)\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2316, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Kuziv/Desktop/Desktop%20Folders/Client%20Projects/MVp/mvp-web-agency/node_modules/msgpackr/struct.js"],"sourcesContent":["\n/*\n\nFor \"any-data\":\n32-55 - record with record ids (-32)\n56 - 8-bit record ids\n57 - 16-bit record ids\n58 - 24-bit record ids\n59 - 32-bit record ids\n250-255 - followed by typed fixed width values\n64-250 msgpackr/cbor/paired data\narrays and strings within arrays are handled by paired encoding\n\nStructure encoding:\n(type - string (using paired encoding))+\n\nType encoding\nencoding byte - fixed width byte - next reference+\n\nEncoding byte:\nfirst bit:\n\t0 - inline\n\t1 - reference\nsecond bit:\n\t0 - data or number\n\t1 - string\n\nremaining bits:\n\tcharacter encoding - ISO-8859-x\n\n\nnull (0xff)+ 0xf6\nnull (0xff)+ 0xf7\n\n*/\n\n\nimport {setWriteStructSlots, RECORD_SYMBOL, addExtension} from './pack.js'\nimport {setReadStruct, mult10, readString} from './unpack.js';\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = ['num', 'object', 'string', 'ascii'];\nTYPE_NAMES[DATE] = 'date';\nconst float32Headers = [false, true, true, false, false, true, true, false];\nlet evalSupported;\ntry {\n\tnew Function('');\n\tevalSupported = true;\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n}\n\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nlet textEncoder, currentSource;\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n\treturn target.utf8Write(string, position, target.byteLength - position)\n} : (textEncoder && textEncoder.encodeInto) ?\n\tfunction(target, string, position) {\n\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t} : false\n\nconst TYPE = Symbol('type');\nconst PARENT = Symbol('parent');\nsetWriteStructSlots(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n\tlet typedStructs = packr.typedStructs || (packr.typedStructs = []);\n\t// note that we rely on pack.js to load stored structures before we get to this point\n\tlet targetView = target.dataView;\n\tlet refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n\tlet safeEnd = target.length - 10;\n\tlet start = position;\n\tif (position > safeEnd) {\n\t\ttarget = makeRoom(position);\n\t\ttargetView = target.dataView;\n\t\tposition -= encodingStart;\n\t\tstart -= encodingStart;\n\t\trefsStartPosition -= encodingStart;\n\t\tencodingStart = 0;\n\t\tsafeEnd = target.length - 10;\n\t}\n\n\tlet refOffset, refPosition = refsStartPosition;\n\n\tlet transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n\tlet nextId = typedStructs.nextId || typedStructs.length;\n\tlet headerSize =\n\t\tnextId < 0xf ? 1 :\n\t\t\tnextId < 0xf0 ? 2 :\n\t\t\t\tnextId < 0xf000 ? 3 :\n\t\t\t\t\tnextId < 0xf00000 ? 4 : 0;\n\tif (headerSize === 0)\n\t\treturn 0;\n\tposition += headerSize;\n\tlet queuedReferences = [];\n\tlet usedAscii0;\n\tlet keyIndex = 0;\n\tfor (let key in object) {\n\t\tlet value = object[key];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: 0,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null,\n\t\t\t\tdate64: null\n\t\t\t};\n\t\t}\n\t\tif (position > safeEnd) {\n\t\t\ttarget = makeRoom(position);\n\t\t\ttargetView = target.dataView;\n\t\t\tposition -= encodingStart;\n\t\t\tstart -= encodingStart;\n\t\t\trefsStartPosition -= encodingStart;\n\t\t\trefPosition -= encodingStart;\n\t\t\tencodingStart = 0;\n\t\t\tsafeEnd = target.length - 10\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\tcase 'number':\n\t\t\t\tlet number = value;\n\t\t\t\t// first check to see if we are using a lot of ids and should default to wide/common format\n\t\t\t\tif (nextId < 200 || !nextTransition.num64) {\n\t\t\t\t\tif (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n\t\t\t\t\t\tif (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n\t\t\t\t\t\t\ttransition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\t\t\t\ttarget[position++] = number;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\ttargetView.setUint32(position, number, true);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (number < 0x100000000 && number >= -0x80000000) {\n\t\t\t\t\t\ttargetView.setFloat32(position, number, true);\n\t\t\t\t\t\tif (float32Headers[target[position + 3] >>> 5]) {\n\t\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\tif (((xShifted = number * mult10[((target[position + 3] & 0x7f) << 1) | (target[position + 2] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n\t\t\t\ttargetView.setFloat64(position, number, true);\n\t\t\t\tposition += 8;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tlet strLength = value.length;\n\t\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\t\tif ((strLength << 2) + refPosition > safeEnd) {\n\t\t\t\t\ttarget = makeRoom((strLength << 2) + refPosition);\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tposition -= encodingStart;\n\t\t\t\t\tstart -= encodingStart;\n\t\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\t\trefPosition -= encodingStart;\n\t\t\t\t\tencodingStart = 0;\n\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t}\n\t\t\t\tif (strLength > ((0xff00 + refOffset) >> 2)) {\n\t\t\t\t\tqueuedReferences.push(key, value, position - start);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet isNotAscii\n\t\t\t\tlet strStart = refPosition;\n\t\t\t\tif (strLength < 0x40) {\n\t\t\t\t\tlet i, c1, c2;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[refPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trefPosition += encodeUtf8(target, value, refPosition);\n\t\t\t\t\tisNotAscii = refPosition - strStart > strLength;\n\t\t\t\t}\n\t\t\t\tif (refOffset < 0xa0 || (refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8))) {\n\t\t\t\t\t// short strings\n\t\t\t\t\tif (isNotAscii) {\n\t\t\t\t\t\tif (!(transition = nextTransition.string8)) {\n\t\t\t\t\t\t\tif (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n\t\t\t\t\t\t\t\t// we can safely change ascii to utf8 in place since they are compatible\n\t\t\t\t\t\t\t\ttransition.__type = UTF8;\n\t\t\t\t\t\t\t\tnextTransition.ascii8 = null;\n\t\t\t\t\t\t\t\tnextTransition.string8 = transition;\n\t\t\t\t\t\t\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, UTF8, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (refOffset === 0 && !usedAscii0) {\n\t\t\t\t\t\tusedAscii0 = true;\n\t\t\t\t\t\ttransition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n\t\t\t\t\t\tbreak; // don't increment position\n\t\t\t\t\t}// else ascii:\n\t\t\t\t\telse if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))\n\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, ASCII, 1);\n\t\t\t\t\ttarget[position++] = refOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Enable ascii16 at some point, but get the logic right\n\t\t\t\t\t//if (isNotAscii)\n\t\t\t\t\t\ttransition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n\t\t\t\t\t//else\n\t\t\t\t\t\t//transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n\t\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\t\tposition += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (value) {\n\t\t\t\t\tif (value.constructor === Date) {\n\t\t\t\t\t\ttransition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n\t\t\t\t\t\ttargetView.setFloat64(position, value.getTime(), true);\n\t\t\t\t\t\tposition += 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else { // null\n\t\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n\t\t\t\t\tif (nextTransition) {\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\ttransition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\ttarget[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n\t\t\t\tif (nextTransition) {\n\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\tfor (let i = 0, l = queuedReferences.length; i < l;) {\n\t\tlet key = queuedReferences[i++];\n\t\tlet value = queuedReferences[i++];\n\t\tlet propertyIndex = queuedReferences[i++];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: propertyIndex - keyIndex,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null\n\t\t\t};\n\t\t}\n\t\tlet newPosition;\n\t\tif (value) {\n\t\t\t/*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */\n\t\t\tlet size;\n\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\tif (refOffset < 0xff00) {\n\t\t\t\ttransition = nextTransition.object16;\n\t\t\t\tif (transition)\n\t\t\t\t\tsize = 2;\n\t\t\t\telse if ((transition = nextTransition.object32))\n\t\t\t\t\tsize = 4;\n\t\t\t\telse {\n\t\t\t\t\ttransition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\t\t\tsize = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t\tnewPosition = pack(value, refPosition);\n\t\t\t//}\n\t\t\tif (typeof newPosition === 'object') {\n\t\t\t\t// re-allocated\n\t\t\t\trefPosition = newPosition.position;\n\t\t\t\ttargetView = newPosition.targetView;\n\t\t\t\ttarget = newPosition.target;\n\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\tposition -= encodingStart;\n\t\t\t\tstart -= encodingStart;\n\t\t\t\tencodingStart = 0;\n\t\t\t} else\n\t\t\t\trefPosition = newPosition;\n\t\t\tif (size === 2) {\n\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\tposition += 2;\n\t\t\t} else {\n\t\t\t\ttargetView.setUint32(position, refOffset, true);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t} else { // null or undefined\n\t\t\ttransition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\ttargetView.setInt16(position, value === null ? -10 : -9, true);\n\t\t\tposition += 2;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\n\tlet recordId = transition[RECORD_SYMBOL];\n\tif (recordId == null) {\n\t\trecordId = packr.typedStructs.length;\n\t\tlet structure = [];\n\t\tlet nextTransition = transition;\n\t\tlet key, type;\n\t\twhile ((type = nextTransition.__type) !== undefined) {\n\t\t\tlet size = nextTransition.__size;\n\t\t\tnextTransition = nextTransition.__parent;\n\t\t\tkey = nextTransition.key;\n\t\t\tlet property = [type, size, key];\n\t\t\tif (nextTransition.enumerationOffset)\n\t\t\t\tproperty.push(nextTransition.enumerationOffset);\n\t\t\tstructure.push(property);\n\t\t\tnextTransition = nextTransition.parent;\n\t\t}\n\t\tstructure.reverse();\n\t\ttransition[RECORD_SYMBOL] = recordId;\n\t\tpackr.typedStructs[recordId] = structure;\n\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t}\n\n\n\tswitch (headerSize) {\n\t\tcase 1:\n\t\t\tif (recordId >= 0x10) return 0;\n\t\t\ttarget[start] = recordId + 0x20;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (recordId >= 0x100) return 0;\n\t\t\ttarget[start] = 0x38;\n\t\t\ttarget[start + 1] = recordId;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (recordId >= 0x10000) return 0;\n\t\t\ttarget[start] = 0x39;\n\t\t\ttargetView.setUint16(start + 1, recordId, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (recordId >= 0x1000000) return 0;\n\t\t\ttargetView.setUint32(start, (recordId << 8) + 0x3a, true);\n\t\t\tbreak;\n\t}\n\n\tif (position < refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\t// adjust positioning\n\t\ttarget.copyWithin(position, refsStartPosition, refPosition);\n\t\trefPosition += position - refsStartPosition;\n\t\ttypedStructs.lastStringStart = position - start;\n\t} else if (position > refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\ttypedStructs.lastStringStart = position - start;\n\t\treturn writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n\t}\n\treturn refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n\tlet nextTransition;\n\tif ((nextTransition = transition.ascii8 || transition.num8)) {\n\t\ttargetView.setInt8(position, value, true);\n\t\tupdatedPosition = position + 1;\n\t\treturn nextTransition;\n\t}\n\tif ((nextTransition = transition.string16 || transition.object16)) {\n\t\ttargetView.setInt16(position, value, true);\n\t\tupdatedPosition = position + 2;\n\t\treturn nextTransition;\n\t}\n\tif (nextTransition = transition.num32) {\n\t\ttargetView.setUint32(position, 0xe0000100 + value, true);\n\t\tupdatedPosition = position + 4;\n\t\treturn nextTransition;\n\t}\n\t// transition.float64\n\tif (nextTransition = transition.num64) {\n\t\ttargetView.setFloat64(position, NaN, true);\n\t\ttargetView.setInt8(position, value);\n\t\tupdatedPosition = position + 8;\n\t\treturn nextTransition;\n\t}\n\tupdatedPosition = position;\n\t// TODO: can we do an \"any\" type where we defer the decision?\n\treturn;\n}\nfunction createTypeTransition(transition, type, size) {\n\tlet typeName = TYPE_NAMES[type] + (size << 3);\n\tlet newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n\tnewTransition.__type = type;\n\tnewTransition.__size = size;\n\tnewTransition.__parent = transition;\n\treturn newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n\tif (!(sharedData instanceof Map))\n\t\treturn sharedData;\n\tlet typed = sharedData.get('typed') || [];\n\tif (Object.isFrozen(typed))\n\t\ttyped = typed.map(structure => structure.slice(0));\n\tlet named = sharedData.get('named');\n\tlet transitions = Object.create(null);\n\tfor (let i = 0, l = typed.length; i < l; i++) {\n\t\tlet structure = typed[i];\n\t\tlet transition = transitions;\n\t\tfor (let [type, size, key] of structure) {\n\t\t\tlet nextTransition = transition[key];\n\t\t\tif (!nextTransition) {\n\t\t\t\ttransition[key] = nextTransition = {\n\t\t\t\t\tkey,\n\t\t\t\t\tparent: transition,\n\t\t\t\t\tenumerationOffset: 0,\n\t\t\t\t\tascii0: null,\n\t\t\t\t\tascii8: null,\n\t\t\t\t\tnum8: null,\n\t\t\t\t\tstring16: null,\n\t\t\t\t\tobject16: null,\n\t\t\t\t\tnum32: null,\n\t\t\t\t\tfloat64: null,\n\t\t\t\t\tdate64: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttransition = createTypeTransition(nextTransition, type, size);\n\t\t}\n\t\ttransition[RECORD_SYMBOL] = i;\n\t}\n\ttyped.transitions = transitions;\n\tthis.typedStructs = typed;\n\tthis.lastTypedStructuresLength = typed.length;\n\treturn named;\n}\nvar sourceSymbol = Symbol.for('source')\nfunction readStruct(src, position, srcEnd, unpackr) {\n\tlet recordId = src[position++] - 0x20;\n\tif (recordId >= 24) {\n\t\tswitch(recordId) {\n\t\t\tcase 24: recordId = src[position++]; break;\n\t\t\t// little endian:\n\t\t\tcase 25: recordId = src[position++] + (src[position++] << 8); break;\n\t\t\tcase 26: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16); break;\n\t\t\tcase 27: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24); break;\n\t\t}\n\t}\n\tlet structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n\tif (!structure) {\n\t\t// copy src buffer because getStructures will override it\n\t\tsrc = Uint8Array.prototype.slice.call(src, position, srcEnd);\n\t\tsrcEnd -= position;\n\t\tposition = 0;\n\t\tif (!unpackr.getStructures)\n\t\t\tthrow new Error(`Reference to shared structure ${recordId} without getStructures method`);\n\t\tunpackr._mergeStructures(unpackr.getStructures());\n\t\tif (!unpackr.typedStructs)\n\t\t\tthrow new Error('Could not find any shared typed structures');\n\t\tunpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n\t\tstructure = unpackr.typedStructs[recordId];\n\t\tif (!structure)\n\t\t\tthrow new Error('Could not find typed structure ' + recordId);\n\t}\n\tvar construct = structure.construct;\n\tvar fullConstruct = structure.fullConstruct;\n\tif (!construct) {\n\t\tconstruct = structure.construct = function LazyObject() {\n\t\t}\n\t\tfullConstruct = structure.fullConstruct = function LoadedObject() {\n\t\t}\n\t\tfullConstruct.prototype = unpackr.structPrototype || {};\n\t\tvar prototype = construct.prototype = unpackr.structPrototype ? Object.create(unpackr.structPrototype) : {};\n\t\tlet properties = [];\n\t\tlet currentOffset = 0;\n\t\tlet lastRefProperty;\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet definition = structure[i];\n\t\t\tlet [ type, size, key, enumerationOffset ] = definition;\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tlet property = {\n\t\t\t\tkey,\n\t\t\t\toffset: currentOffset,\n\t\t\t}\n\t\t\tif (enumerationOffset)\n\t\t\t\tproperties.splice(i + enumerationOffset, 0, property);\n\t\t\telse\n\t\t\t\tproperties.push(property);\n\t\t\tlet getRef;\n\t\t\tswitch(size) { // TODO: Move into a separate function\n\t\t\t\tcase 0: getRef = () => 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet ref = source.bytes[position + property.offset];\n\t\t\t\t\t\treturn ref >= 0xf6 ? toConstant(ref) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint16(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint32(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tproperty.getRef = getRef;\n\t\t\tcurrentOffset += size;\n\t\t\tlet get;\n\t\t\tswitch(type) {\n\t\t\t\tcase ASCII:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tproperty.multiGetCount = 0;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (source.srcString) {\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\treturn readString(src, ref + refStart, end - ref);\n\t\t\t\t\t\t//return src.toString('latin1', ref + refStart, end + refStart);\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase UTF8: case OBJECT_DATA:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (type === UTF8) {\n\t\t\t\t\t\t\treturn src.toString('utf8', ref + refStart, end + refStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentSource = source;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn unpackr.unpack(src, { start: ref + refStart, end: end + refStart });\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tcurrentSource = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tswitch(size) {\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet position = source.position + property.offset;\n\t\t\t\t\t\t\t\tlet value = dataView.getInt32(position, true)\n\t\t\t\t\t\t\t\tif (value < 0x20000000) {\n\t\t\t\t\t\t\t\t\tif (value > -0x1f000000)\n\t\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t\tif (value > -0x20000000)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(value & 0xff);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet fValue = dataView.getFloat32(position, true);\n\t\t\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\tlet multiplier = mult10[((src[position + 3] & 0x7f) << 1) | (src[position + 2] >> 7)]\n\t\t\t\t\t\t\t\treturn ((multiplier * fValue + (fValue > 0 ? 0.5 : -0.5)) >> 0) / multiplier;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet value = dataView.getFloat64(source.position + property.offset, true);\n\t\t\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\t\t\tlet byte = src[source.position + property.offset];\n\t\t\t\t\t\t\t\t\tif (byte >= 0xf6)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(byte);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet value = src[source.position + property.offset];\n\t\t\t\t\t\t\t\treturn value < 0xf6 ? value : toConstant(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE:\n\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\treturn new Date(dataView.getFloat64(source.position + property.offset, true));\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tproperty.get = get;\n\t\t}\n\t\t// TODO: load the srcString for faster string decoding on toJSON\n\t\tif (evalSupported) {\n\t\t\tlet objectLiteralProperties = [];\n\t\t\tlet args = [];\n\t\t\tlet i = 0;\n\t\t\tlet hasInheritedProperties;\n\t\t\tfor (let property of properties) { // assign in enumeration order\n\t\t\t\tif (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n\t\t\t\t\t// these properties are not eagerly evaluated and this can be used for creating properties\n\t\t\t\t\t// that are not serialized as JSON\n\t\t\t\t\thasInheritedProperties = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });\n\t\t\t\tlet valueFunction = 'v' + i++;\n\t\t\t\targs.push(valueFunction);\n\t\t\t\tobjectLiteralProperties.push('o[' + JSON.stringify(property.key) + ']=' + valueFunction + '(s)');\n\t\t\t}\n\t\t\tif (hasInheritedProperties) {\n\t\t\t\tobjectLiteralProperties.push('__proto__:this');\n\t\t\t}\n\t\t\tlet toObject = (new Function(...args, 'var c=this;return function(s){var o=new c();' + objectLiteralProperties.join(';') + ';return o;}')).apply(fullConstruct, properties.map(prop => prop.get));\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\treturn toObject.call(this, this[sourceSymbol]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\t// return an enumerable object with own properties to JSON stringify\n\t\t\t\t\tlet resolved = {};\n\t\t\t\t\tfor (let i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: check alwaysLazyProperty\n\t\t\t\t\t\tlet key = properties[i].key;\n\n\t\t\t\t\t\tresolved[key] = this[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t},\n\t\t\t\t// not enumerable or anything\n\t\t\t});\n\t\t}\n\t}\n\tvar instance = new construct();\n\tinstance[sourceSymbol] = {\n\t\tbytes: src,\n\t\tposition,\n\t\tsrcString: '',\n\t\tbytesEnd: srcEnd\n\t}\n\treturn instance;\n}\nfunction toConstant(code) {\n\tswitch(code) {\n\t\tcase 0xf6: return null;\n\t\tcase 0xf7: return undefined;\n\t\tcase 0xf8: return false;\n\t\tcase 0xf9: return true;\n\t}\n\tthrow new Error('Unknown constant');\n}\nfunction withSource(get) {\n\treturn function() {\n\t\treturn get(this[sourceSymbol]);\n\t}\n}\n\nfunction saveState() {\n\tif (currentSource) {\n\t\tcurrentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n\t\tcurrentSource.position = 0;\n\t\tcurrentSource.bytesEnd = currentSource.bytes.length;\n\t}\n}\nfunction prepareStructures(structures, packr) {\n\tif (packr.typedStructs) {\n\t\tlet structMap = new Map();\n\t\tstructMap.set('named', structures);\n\t\tstructMap.set('typed', packr.typedStructs);\n\t\tstructures = structMap;\n\t}\n\tlet lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n\tstructures.isCompatible = existing => {\n\t\tlet compatible = true;\n\t\tif (existing instanceof Map) {\n\t\t\tlet named = existing.get('named') || [];\n\t\t\tif (named.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t\tlet typed = existing.get('typed') || [];\n\t\t\tif (typed.length !== lastTypedStructuresLength)\n\t\t\t\tcompatible = false;\n\t\t} else if (existing instanceof Array || Array.isArray(existing)) {\n\t\t\tif (existing.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t}\n\t\tif (!compatible)\n\t\t\tpackr._mergeStructures(existing);\n\t\treturn compatible;\n\t};\n\tpackr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n\treturn structures;\n}\n\nsetReadStruct(readStruct, onLoadedStructures, saveState);\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3112, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Kuziv/Desktop/Desktop%20Folders/Client%20Projects/MVp/mvp-web-agency/node_modules/msgpackr/stream.js"],"sourcesContent":["import { Transform } from 'stream'\nimport { Packr } from './pack.js'\nimport { Unpackr } from './unpack.js'\nvar DEFAULT_OPTIONS = {objectMode: true}\n\nexport class PackrStream extends Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {}\n\t\toptions.writableObjectMode = true\n\t\tsuper(options)\n\t\toptions.sequential = true\n\t\tthis.packr = options.packr || new Packr(options)\n\t}\n\t_transform(value, encoding, callback) {\n\t\tthis.push(this.packr.pack(value))\n\t\tcallback()\n\t}\n}\n\nexport class UnpackrStream extends Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {}\n\t\toptions.objectMode = true\n\t\tsuper(options)\n\t\toptions.structures = []\n\t\tthis.unpackr = options.unpackr || new Unpackr(options)\n\t}\n\t_transform(chunk, encoding, callback) {\n\t\tif (this.incompleteBuffer) {\n\t\t\tchunk = Buffer.concat([this.incompleteBuffer, chunk])\n\t\t\tthis.incompleteBuffer = null\n\t\t}\n\t\tlet values\n\t\ttry {\n\t\t\tvalues = this.unpackr.unpackMultiple(chunk)\n\t\t} catch(error) {\n\t\t\tif (error.incomplete) {\n\t\t\t\tthis.incompleteBuffer = chunk.slice(error.lastPosition)\n\t\t\t\tvalues = error.values\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow error\n\t\t} finally {\n\t\t\tfor (let value of values || []) {\n\t\t\t\tif (value === null)\n\t\t\t\t\tvalue = this.getNullValue()\n\t\t\t\tthis.push(value)\n\t\t\t}\n\t\t}\n\t\tif (callback) callback()\n\t}\n\tgetNullValue() {\n\t\treturn Symbol.for(null)\n\t}\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AACA,IAAI,kBAAkB;IAAC,YAAY;AAAI;AAEhC,MAAM,oBAAoB,kHAAS;IACzC,YAAY,OAAO,CAAE;QACpB,IAAI,CAAC,SACJ,UAAU,CAAC;QACZ,QAAQ,kBAAkB,GAAG;QAC7B,KAAK,CAAC;QACN,QAAQ,UAAU,GAAG;QACrB,IAAI,CAAC,KAAK,GAAG,QAAQ,KAAK,IAAI,IAAI,2JAAK,CAAC;IACzC;IACA,WAAW,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE;QACrC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAC1B;IACD;AACD;AAEO,MAAM,sBAAsB,kHAAS;IAC3C,YAAY,OAAO,CAAE;QACpB,IAAI,CAAC,SACJ,UAAU,CAAC;QACZ,QAAQ,UAAU,GAAG;QACrB,KAAK,CAAC;QACN,QAAQ,UAAU,GAAG,EAAE;QACvB,IAAI,CAAC,OAAO,GAAG,QAAQ,OAAO,IAAI,IAAI,+IAAO,CAAC;IAC/C;IACA,WAAW,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE;QACrC,IAAI,IAAI,CAAC,gBAAgB,EAAE;YAC1B,QAAQ,OAAO,MAAM,CAAC;gBAAC,IAAI,CAAC,gBAAgB;gBAAE;aAAM;YACpD,IAAI,CAAC,gBAAgB,GAAG;QACzB;QACA,IAAI;QACJ,IAAI;YACH,SAAS,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC;QACtC,EAAE,OAAM,OAAO;YACd,IAAI,MAAM,UAAU,EAAE;gBACrB,IAAI,CAAC,gBAAgB,GAAG,MAAM,KAAK,CAAC,MAAM,YAAY;gBACtD,SAAS,MAAM,MAAM;YACtB,OAEC,MAAM;QACR,SAAU;YACT,KAAK,IAAI,SAAS,UAAU,EAAE,CAAE;gBAC/B,IAAI,UAAU,MACb,QAAQ,IAAI,CAAC,YAAY;gBAC1B,IAAI,CAAC,IAAI,CAAC;YACX;QACD;QACA,IAAI,UAAU;IACf;IACA,eAAe;QACd,OAAO,OAAO,GAAG,CAAC;IACnB;AACD","ignoreList":[0]}},
    {"offset": {"line": 3180, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Kuziv/Desktop/Desktop%20Folders/Client%20Projects/MVp/mvp-web-agency/node_modules/msgpackr/iterators.js"],"sourcesContent":["import { Packr } from './pack.js'\nimport { Unpackr } from './unpack.js'\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function packIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return packIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return packIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * packIterSync (objectIterator, options) {\n  const packr = new Packr(options)\n  for (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\nasync function * packIterAsync (objectIterator, options) {\n  const packr = new Packr(options)\n  for await (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function unpackIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const unpackr = new Unpackr(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = unpackr.unpackMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\nexport const decodeIter = unpackIter\nexport const encodeIter = packIter"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AASO,SAAS,SAAU,cAAc,EAAE,UAAU,CAAC,CAAC;IACpD,IAAI,CAAC,kBAAkB,OAAO,mBAAmB,UAAU;QACzD,MAAM,IAAI,MAAM;IAClB,OAAO,IAAI,OAAO,cAAc,CAAC,OAAO,QAAQ,CAAC,KAAK,YAAY;QAChE,OAAO,aAAa,gBAAgB;IACtC,OAAO,IAAI,OAAO,eAAe,IAAI,KAAK,cAAc,OAAO,cAAc,CAAC,OAAO,aAAa,CAAC,KAAK,YAAY;QAClH,OAAO,cAAc,gBAAgB;IACvC,OAAO;QACL,MAAM,IAAI,MAAM;IAClB;AACF;AAEA,UAAW,aAAc,cAAc,EAAE,OAAO;IAC9C,MAAM,QAAQ,IAAI,2JAAK,CAAC;IACxB,KAAK,MAAM,SAAS,eAAgB;QAClC,MAAM,MAAM,IAAI,CAAC;IACnB;AACF;AAEA,gBAAiB,cAAe,cAAc,EAAE,OAAO;IACrD,MAAM,QAAQ,IAAI,2JAAK,CAAC;IACxB,WAAW,MAAM,SAAS,eAAgB;QACxC,MAAM,MAAM,IAAI,CAAC;IACnB;AACF;AASO,SAAS,WAAY,cAAc,EAAE,UAAU,CAAC,CAAC;IACtD,IAAI,CAAC,kBAAkB,OAAO,mBAAmB,UAAU;QACzD,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,UAAU,IAAI,+IAAO,CAAC;IAC5B,IAAI;IACJ,MAAM,SAAS,CAAC;QACd,IAAI;QACJ,4EAA4E;QAC5E,IAAI,YAAY;YACd,QAAQ,OAAO,MAAM,CAAC;gBAAC;gBAAY;aAAM;YACzC,aAAa;QACf;QAEA,IAAI;YACF,SAAS,QAAQ,cAAc,CAAC;QAClC,EAAE,OAAO,KAAK;YACZ,IAAI,IAAI,UAAU,EAAE;gBAClB,aAAa,MAAM,KAAK,CAAC,IAAI,YAAY;gBACzC,SAAS,IAAI,MAAM;YACrB,OAAO;gBACL,MAAM;YACR;QACF;QACA,OAAO;IACT;IAEA,IAAI,OAAO,cAAc,CAAC,OAAO,QAAQ,CAAC,KAAK,YAAY;QACzD,OAAO,AAAC,UAAW;YACjB,KAAK,MAAM,SAAS,eAAgB;gBAClC,OAAQ,OAAO;YACjB;QACF;IACF,OAAO,IAAI,OAAO,cAAc,CAAC,OAAO,aAAa,CAAC,KAAK,YAAY;QACrE,OAAO,AAAC,gBAAiB;YACvB,WAAW,MAAM,SAAS,eAAgB;gBACxC,OAAQ,OAAO;YACjB;QACF;IACF;AACF;AACO,MAAM,aAAa;AACnB,MAAM,aAAa","ignoreList":[0]}},
    {"offset": {"line": 3265, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Kuziv/Desktop/Desktop%20Folders/Client%20Projects/MVp/mvp-web-agency/node_modules/msgpackr/node-index.js"],"sourcesContent":["export { Packr, Encoder, addExtension, pack, encode, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } from './pack.js'\nexport { Unpackr, Decoder, C1, unpack, unpackMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled } from './unpack.js'\nimport './struct.js'\nexport { PackrStream, UnpackrStream, PackrStream as EncoderStream, UnpackrStream as DecoderStream } from './stream.js'\nexport { decodeIter, encodeIter } from './iterators.js'\nexport const useRecords = false\nexport const mapsAsObjects = true\nimport { setExtractor } from './unpack.js'\nimport { createRequire } from 'module'\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor\n\ttry {\n\t\tif (typeof require == 'function')\n\t\t\textractor = require('msgpackr-extract')\n\t\telse\n\t\t\textractor = createRequire(import.meta.url)('msgpackr-extract')\n\t\tif (extractor)\n\t\t\tsetExtractor(extractor.extractStrings)\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AAIA;;;;;;AAHO,MAAM,aAAa;AACnB,MAAM,gBAAgB;;;AAI7B,MAAM,6BAA6B,QAAQ,GAAG,CAAC,qCAAqC,KAAK,aAAa,QAAQ,GAAG,CAAC,qCAAqC,CAAC,WAAW,OAAO;AAE1K,IAAI,CAAC,4BAA4B;IAChC,IAAI;IACJ,IAAI;QACH,wCACC;;;QAGD,IAAI,WACH,IAAA,oJAAY,EAAC,UAAU,cAAc;IACvC,EAAE,OAAO,OAAO;IACf,4BAA4B;IAC7B;AACD","ignoreList":[0]}}]
}